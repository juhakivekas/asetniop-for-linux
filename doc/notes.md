Sources of information, a messy list of links
---------------------------------------------

Info about Linux keyboard drivers

	The Linux keyboard driver
	Linuxjournal Issue 14
	Jun 01, 1995  By Andries E. Brouwer	
	
	http://www.linuxjournal.com/article/1080

Good graph on Linux input architecture
	
	https://en.wikipedia.org/wiki/Evdev
	https://en.wikipedia.org/wiki/Evdev#/media/File:Linux_kernel_and_gaming_input-output_latency.svg

About linux input drivers

	https://www.kernel.org/doc/Documentation/input/input.txt

Asetniop Github, and the publicly hosted kaymap

	https://github.com/asetniop
	http://asetniop.com/one/resources/keymaps/test-keymap.json

Libevdev documantation

	https://www.freedesktop.org/software/libevdev/doc/latest/modules.html

About evdev ioctls
	
	http://thiemonge.org/getting-started-with-uinput

what is EVIOCGRAB?

	http://unix.stackexchange.com/questions/126974/where-do-i-find-ioctl-eviocgrab-documented#126996
	http://www.gossamer-threads.com/lists/linux/kernel/676540

General data flow
-----------------

	IRC-log #xorg-devel

	07:53 < guttula> I'm trying to implement an experimental input device (asetniop) and I'd need to hijack the dataflow of the keyboard at as low a level as 
	                 possible.
	07:54 < guttula> Should this processing happen in X or already earlier?
	07:56 < guttula> basically i need to aggregate several keypress and keyrelease events, alter them, and create output that can be fed to whereever those events were going in the first place.
	07:56 < whot> probably best to create a uinput device, hook onto the real device and EVIOCGRAB it, then pump the events through
	07:57 < guttula> as i'm not very familiar with the linux input architecture, are those X objects or kernel objects?
	07:57 < whot> uinput will create a new kernel dvevice
	07:58 < whot> so the whole thing sits below X
	07:58 < guttula> great, system wide is what i want
	07:59 < guttula> thanks a lot for the quick info, I've only ever worked with input hardware, so software solutions are still a but hazy got me :)
	08:00 < whot> look up libevdev, that's your best option here
	08:00 < whot> if you grab the device (EVIOCGRAB) you prevent the events from being seen by anyone else, so even though X would see the original device it won't get events
	08:01 < whot> then you just read the events as they come in, change them as required and send them on through your own input device
	08:01 < guttula> but X will see the new one?
	
Keyboard events
---------------

At least these events are generated by my keyboard.

  Event type 0 (EV_SYN)
  Event type 1 (EV_KEY)
  Event type 4 (EV_MSC)
  Event type 17 (EV_LED)
  Event type 20 (EV_REP)

Bad ideas
---------
05.06.16 10:03

From the documantation of libevdev_grab, the function that does EVIOCGRAB:

	This is generally a bad idea. Don't do this.

This is exactly what I want to do. I'll just disregard expert advice then?

Pythonisms
----------
05.06.16 10:43

I've wirtten a lot of python lately, and the coding style related to python includes a lot of installing libraries through pip and reading documentation.
The projects I've done in C have almost always been on such a low level that I implemented everyting myself.
Now that I'm used to the python way of doing things I realize this works fot C as well.
I'll be using plenty of external libraries in oder to hook onto the information that I have.

Since I'm working with linux and want this project to be as portable as possible, I'll be using libevdev, a nice wrapper around the ioclt interface.
Since I'm implenmenting somebody elses logic I'll have to interfacfe with the data related to that logic.
The asetniop keyboard layouts are distributed in JSON files, and preferrably I'd be reading these straight into my implementation with a JSON parsing library.
This way of programming is a lot more enjoyable since I don't need to concentrate on small details, but I can actually do the work that's relevant.
Instead of the projects advancing faster, I spend more time thinking about architecture and design choices.
I like this and I bet it leads to better code.

Writing as little and as clear code as possible is one of my goals fot this project.
